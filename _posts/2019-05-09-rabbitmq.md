---
layout: post
title: RabbitMQ原理
date: 2019-05-09
tags: 后台框架
---

# 安装、配置及常规命令

## Centos下的安装方法

```bash
# 有两种方式可选：

# 方式1：直接使用yum现有的库：
yum install erlang
yum install rabbitmq

# 方式2：官网使用最新的版本安装：
# 安装erlang的repo
curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash
# 安装rabbitmq的repo
curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash
# 安装
yum install erlang
yum install rabbitmq
```

## 基础配置

```bash
# 允许management，启动web服务，可以从15672端口看到rabbitmq的队列数据
rabbitmq-plugins enable rabbitmq_management

# 设置用户名和密码
rabbitmqctl add_user keen-rabbit keen123
rabbitmqctl set_user_tags keen-rabbit administrator
rabbitmqctl set_permissions -p / keen-rabbit  ".*" ".*" ".*"
```

## 常规命令

```bash
# 后台启动rabbitmq的几种方式
方式1：service rabbitmq start   / service rabbitmq restart
方式2：systemctl start rabbitmq / systemctl restart rabbitmq
方式3：rabbitmq-server --detached

# 停止和启动rabbitmq的结点
rabbitmqctl stop_app
rabbitmqctl start_app

# 重置rabbitmq（比如删除队列、清除用户密码。注意，这个操作会清除用户密码，记得运行用户名密码重置的3条命令）。运行前，需要先停止节点服务，rabbitmqctl stop_app
rabbitmqctl reset

# 查看队列以及交换器
rabbitmqctl list_queues
rabbitmqctl list_exchanges
```

# 模型和原理

## 工作队列模型

一个生产者，多个消费者竞争消费队列内的消息（队列内的同一个消息，不会被多个消费者拿到）

### producer

```go
package main

import (
	"log"

	"github.com/streadway/amqp"
)

func failOnError(err error, msg string) {
	if err != nil {
		log.Fatalf("%s: %s", msg, err)
	}
}

func main() {
	// 与rabbitmq-server建立连接
	conn, err := amqp.Dial("amqp://keen-rabbit:keen123@192.168.0.100:5672/")
	failOnError(err, "Failed to connect to RabbitMQ")
	defer conn.Close()

	// channel是一条连接的任务抽象层，后续所有的操作，都是基于此连接的api的操作
	ch, err := conn.Channel()
	failOnError(err, "Failed to open a channel")
	defer ch.Close()

	// 定义一个队列，用于发送消息。注意，只有队列不存在的时候，才会创建队列。如果队列存在，则获取该队列
	q, err := ch.QueueDeclare(
		"hello", // name
		false,   // durable
		false,   // delete when unused
		false,   // exclusive
		false,   // no-wait
		nil,     // arguments
	)
	failOnError(err, "Failed to declare a queue")

	// 发布消息
	body := "Hello World!"
	err = ch.Publish(
		"",     // exchange
		q.Name, // routing key
		false,  // mandatory
		false,  // immediate
		amqp.Publishing{
            DeliveryMode: amqp.Persistent,  // 表示某条未消费的消息是否需要队列重启后依然存在于队列中
			ContentType: "text/plain",
			Body:        []byte(body),
		})
	failOnError(err, "Failed to publish a message")
}

```

### consumer

```go
package main

import (
	"log"

	"github.com/streadway/amqp"
)

func failOnError(err error, msg string) {
	if err != nil {
		log.Fatalf("%s: %s", msg, err)
	}
}

func main() {
	// 与rabbitmq-server建立连接
	conn, err := amqp.Dial("amqp://keen-rabbit:keen123@192.168.0.100:5672/")
	failOnError(err, "Failed to connect to RabbitMQ")
	defer conn.Close()

	// 声明连接通道
	ch, err := conn.Channel()
	failOnError(err, "Failed to open a channel")
	defer ch.Close()

	// 查找hello队列
	q, err := ch.QueueDeclare(
		"hello", // name
		false,   // durable
		false,   // delete when usused
		false,   // exclusive
		false,   // no-wait
		nil,     // arguments
	)
	failOnError(err, "Failed to declare a queue")

	// 告诉rabbitmq-server给我们发消息，声明一下我们是消费者，向rabbitmq注册一下。不注册的话，rabbitmq是不会返回数据的。
	// 声明完了，会返回一个channel通道msgs，相当于建立了管道连接，后续会通过此管道给我们发数据
	msgs, err := ch.Consume(
		q.Name, // queue
		"",     // consumer
		true,   // auto-ack
		false,  // exclusive
		false,  // no-local
		false,  // no-wait
		nil,    // args
	)
	failOnError(err, "Failed to register a consumer")

	// 创建一个无缓存的channel，用来不死锁的卡住当前主线程的goroutine，防止主线程退出
	// 任何goroutine，都可以向此channel发送数据，用以退出当前主线程
	forever := make(chan bool)

	go func() {
		// 开始循环读取管道数据
		for d := range msgs {
			log.Printf("Received a message: %s", d.Body)
		}
	}()

	log.Printf(" [*] Waiting for messages. To exit press CTRL+C")
	// 无缓存，所以读会卡死，直到有写入数据
	<-forever
}

```

consumer可以有多个实例，这样同时消费队列中的数据，并互斥进行

### 说明及注意点

```go
// 以上示例，设置了auto-ack为true。这样，当rabbitmq分发一条消息到一个消费者，消费者就会立刻自动回复说表示它已收到该消息。这样rabbitmq就会立刻把此消息标记为已删除。如果此时杀掉该消费者，这条消息也就丢弃了。而且，之前分发给这个消费者的还未处理的消息，也都丢弃了
// 如果希望消息不丢失，也即一个消费者挂了，这条消息能被重新投递给其他活着的消费者，auto-ack就需要设置为false。这样，如果消费者不在了（channel被关闭了、连接关闭了、TCP连接丢失了等都称为不在）而导致未发送ack，那么rabbitmq就会认为这个消息还没有被消费过，就会重新投递到队列中去。这样，如果其他消费者在线，这条消息就会优先被投递给这个消费者。
```

## 发布订阅模型

