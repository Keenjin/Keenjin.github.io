---
layout: post
title: Go学习笔记
date: 2019-05-11
tags: go  
---

# CentOS安装go

参考：<https://www.jianshu.com/p/c314f2edf19e>

# 标准库

| Go语言标准库包名 | 功  能                                                          |
| ---------------- | ----------------------------------------------------------------- |
| bufio            | 带缓冲的 I/O 操作                                           |
| bytes            | 实现字节操作                                                |
| container        | 封装堆、列表和环形列表等容器                        |
| crypto           | 加密算法                                                      |
| database         | 数据库驱动和接口                                          |
| debug            | 各种调试文件格式访问及调试功能                     |
| encoding         | 常见算法如 JSON、XML、Base64 等                           |
| flag             | 命令行解析                                                   |
| fmt              | 格式化操作                                                   |
| go               | Go 语言的词法、语法树、类型等。可通过这个包进行代码信息提取和修改 |
| html             | HTML 转义及模板系统                                        |
| image            | 常见图形格式的访问及生成                              |
| io               | 实现 I/O 原始访问接口及访问封装                      |
| math             | 数学库                                                         |
| net              | 网络库，支持 Socket、HTTP、邮件、RPC、SMTP 等        |
| os               | 操作系统平台不依赖平台操作封装                     |
| path             | 兼容各操作系统的路径操作实用函数                  |
| plugin           | Go 1.7 加入的插件系统。支持将代码编译为插件，按需加载 |
| reflect          | 语言反射支持。可以动态获得代码中的类型信息，获取和修改变量的值 |
| regexp           | 正则表达式封装                                             |
| runtime          | 运行时接口                                                   |
| sort             | 排序接口                                                      |
| strings          | 字符串转换、解析及实用函数                           |
| time             | 时间接口                                                      |
| text             | 文本模板及 Token 词法器                                   |

# 转义符

| 转移符 | 含  义                           |
| ------ | ---------------------------------- |
| \r     | 回车符（返回行首）        |
| \n     | 换行符（直接跳到下一行的同列位置） |
| \t     | 制表符                          |
| \'     | 单引号                          |
| \"     | 双引号                          |
| \\     | 反斜杠                          |

# 格式化

| 动  词 | 功  能                                 |
| ------ | ---------------------------------------- |
| %v     | 按值的本来值输出                 |
| %+v    | 在 %v 基础上，对结构体字段名和值进行展开 |
| %#v    | 输出 Go 语言语法格式的值       |
| %T     | 输出 Go 语言语法格式的类型和值 |
| %%     | 输出 % 本体                          |
| %b     | 整型以二进制方式显示           |
| %o     | 整型以八进制方式显示           |
| %d     | 整型以十进制方式显示           |
| %x     | 整型以十六进制方式显示        |
| %X     | 整型以十六进制、字母大写方式显示 |
| %U     | Unicode 字符                           |
| %f     | 浮点数                                |
| %p     | 指针，十六进制方式显示        |

# defer, panic, recover的使用

这里类似c++的try catch异常捕获，一般使用方法如下：  

```go
package main
 
import "fmt"
 
func main(){
    defer func(){ // 必须要先声明defer，否则不能捕获到panic异常
        fmt.Println("c")
        if err:=recover();err!=nil{
            fmt.Println(err) // 这里的err其实就是panic传入的内容，55
        }
        fmt.Println("d")
    }()
    f()
}
 
func f(){
    fmt.Println("a")
    panic(55)
    fmt.Println("b")
    fmt.Println("f")
}
输出结果：
a
c
55
d
exit code 0, process exited normally.
```

# zip解压

```go
import (
    "io"
    "os"
    "archive/zip"
    "path/filepath"
)

func UnZip(archive, target_dir string) error {
	reader, err := zip.OpenReader(archive)
	if err != nil {
		return err
	}

	if err := os.MkdirAll(target_dir, 755); err != nil {
		return err
	}

	for _, file := range reader.File {
		path := filepath.Join(target_dir, file.Name)
		if file.FileInfo().IsDir() {
			os.MkdirAll(path, file.Mode())
			continue
		}

		fileReader, err := file.Open()
		if err != nil {
			return err
		}
		defer fileReader.Close()

		targetFile, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
		if err != nil {
			return err
		}
		defer targetFile.Close()

		if _, err := io.Copy(targetFile, fileReader); err != nil {
			return err
		}
	}

	return nil
}

```

# http下载

```go
import (
	"io"
	"net/http"
	"os"
)

func Download(url, dst_path string) {
	res, err := http.Get(url)
	if err != nil {
		panic(err)
	}
	f, err := os.Create(dst_path)
	if err != nil {
		panic(err)
	}
	io.Copy(f, res.Body)
}
```

# go管道与shell程序通信

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os/exec"
	"strings"
)

func main() {
	xxx_cmd := exec.Command("./xxxxx", "/xxx")
	xxx_In, _ := xxx_cmd.StdinPipe()
	xxx_Out, _ := xxx_cmd.StdoutPipe()

	xxx_cmd.Start()

	scanner := bufio.NewScanner(xxx_Out)

	io.WriteString(xxx_In, "word/00bc595ba1ca523347d86c952972e740\n")
	for scanner.Scan() {
		value := scanner.Text()
		fmt.Println(value)
		if strings.TrimSpace(value) == "====================" {
			break
		}

	}

	io.WriteString(xxx_In, "word/0041811cb9868b31107bfe5a7fdbc57a\n")
	for scanner.Scan() {
		value := scanner.Text()
		fmt.Println(value)
		if strings.TrimSpace(value) == "====================" {
			break
		}

	}
}

```

# 多个指令同时运行

简单示例：

```go
cmd1 := exec.Command("ps", "-ef")
cmd2 := exec.Command("grep", "engine_mirror_server")
cmd3 := exec.Command("grep", "-v", "grep")

cmd3.Stdin, _ = cmd2.StdoutPipe()
cmd2.Stdin, _ = cmd1.StdoutPipe()

cmd3.Stdout = os.Stdout
cmd3.Stderr = os.Stderr

cmd3.Start()
cmd2.Start()
cmd1.Run()
cmd2.Wait()
```

统一函数

```go
func runCombineCommand(args ...string) ([]byte, error) {
	var err error

	var cmdArray []*exec.Cmd
	var arg []string
	var stdout, stderr bytes.Buffer

	for _, v := range args {
		if v != "|" {
			arg = append(arg, v)
		} else {
			cmd := exec.Command(arg[0], arg[1:]...)
			cmdArray = append(cmdArray, cmd)
			arg = arg[:0]
		}
	}
	if len(arg) > 0 {
		cmd := exec.Command(arg[0], arg[1:]...)
		cmdArray = append(cmdArray, cmd)
		arg = arg[:0]
	}

	for i, cmd := range cmdArray {
		if i < len(cmdArray)-1 {
			cmdArray[i+1].Stdin, err = cmd.StdoutPipe()
			if err != nil {
				return nil, err
			}
		} else {
			cmd.Stdout = &stdout
			cmd.Stderr = &stderr
			break
		}
	}

	for i, cmd := range cmdArray {
		if i == 0 {
			continue
		} else if i == len(cmdArray)-1 {
			err = cmd.Start()
			if err != nil {
				return nil, err
			}
			err = cmdArray[0].Run()
			if err != nil {
				return nil, err
			}
			err = cmd.Wait()
			if err != nil {
				return nil, err
			}
		} else {
			err = cmd.Start()
			if err != nil {
				return nil, err
			}
		}
	}

	return stdout.Bytes(), nil
}

b, _ := runCombineCommand("ps", "-ef", "|", "grep", "engine_mirror_server", "|", "grep", "-v", "grep", "|", "awk", "{printf $2}")
fmt.Printf("result: %s", string(b))
```

# 清空数组方式

```go
letters := []string{"a", "b", "c", "d"}

// 直接在原 slice 上操作，故无 GC 行为
// 清空后 cap 值和之前相同，len 值清零
letters = letters[:0]

// 类似 C 语言中赋值空指针，原内容会被 GC 处理
// 清空后 cap 值清零，len 值清零
letters = nil
```

# 大文件MD5

```go
// CaclBigFileMD5 计算大文件MD5
func CaclBigFileMD5(filePath string) []byte {
	hash := md5.New()

	file, err := os.Open(filePath)
	if err != nil {
		return nil
	}

	for {
		buf := make([]byte, 8192)

		readSize, err := file.Read(buf)
		if err != nil || readSize == 0 {
			break
		}

		hash.Write(buf[:readSize])
	}

	return hash.Sum(nil)
}
```