---
layout: post
title: windbg帮助文档
date: 2019-01-11
tags: 调试  
---

# Debugging Tools for Windows (WinDbg, KD, CDB, NTSD)

```txt
1、3种方式获取调试工具：WDK、SDK、standalone tool set
```

## Getting Started with Windows Debugging

```txt
调试基本流程：
1、确定主机和目标机
2、确定调试内核还是应用层
3、按需选择调试工具
4、选择主机和目标机连接方式：网络、串口、USB、虚拟机
5、选择32位还是64位调试工具
6、配置符号
7、配置源码
8、熟悉调试工具操作方法
9、熟悉调试技术
10、使用调试指令
11、使用调试扩展
```

### Getting Started with WinDbg (User-Mode)

```txt
为什么不注入到目标进程，都可以进行调试？

答：因为操作系统内核体系支持，只要应用层调用DebugActiveProcess启动调试，操作系统会触发int 3中断（从调用栈里看是这玩意儿：ntdll!DbgUiRemoteBreakin、ntdll!DbgBreakPoint），这个中断向量表里填充的响应函数是kiTrap，这个东西首先分发给调试系统，然后才会分发给中断异常系统。所以本质是利用中断和系统本身的内核级调试支持。剩下的，就是各种调试事件的使用。
```

```txt
如何调试一个应用层程序？步骤如下：
1、.sympath srv*xxxx        xxxx表示符号路径，可以是网络路径，微软的符号服务器路径：http://msdl.microsoft.com/download/symbols，当然，这里可以直接使用界面设置
2、.reload      加载模块pdb，将从刚设置的位置搜索
3、x notepad!*  检查符号加载
4、g
5、菜单Break——>Debug
6、lm
7、k
8、bu notepad!WinMain
9、bl       设置完断点，列一下确认下
10、~       罗列所有的线程id
11、~3s     切换到线程id为3的线程栈，然后k
12、!analyze -v     中断后，可以使用命令分析，得出基本结论和中断位置
13、qd      Quit and Detach
```

### Getting Started with WinDbg (Kernel-Mode)

```txt
调试驱动准备环境：
1、双机调试
2、双机连接方式：
（1）Win8及以上，可以使用网络连接
（2）Win8以下只能用usb、serial、1394
3、启动连接会话
（1）手动方法：https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-kernel-mode-debugging-in-windbg--cdb--or-ntsd
（2）自动方法：使用Virtual-KD工具，将目录里面的target拷贝到目标机器，执行vminstall.exe；然后主机运行vmmon.exe，启动windbg即可

```

```txt
如何调试一个驱动？步骤如下：
1、建立双机连接
2、设置符号表
3、lm
4、x nt!*CreateProcess*     检查符号表
5、dt nt!_FILE_OBJECT       常用结构查看
6、bu nt!MmCreateProcessAddressSpace    设置断点
7、bl
8、g
9、k
10、bc *            清除所有断点
11、!process 0 0    输出所有当前进程的基本信息
12、!process ffffe00000d5290 2      输出某个进程的线程信息（ffffe00000d5290是进程句柄，标志进程地址）
13、!thread ffffe00000e6d080        某个线程的相关信息，特别是包括堆栈详细信息
14、!devnode 0 1    查看所有即插即用设备树信息
15、!devnode 0 9    查看设备信息及硬件资源
16、!devnode 0 1 disk       查看服务名为disk的设备信息
17、!devstack 0xffffe00001159610    查看pdo为0xffffe00001159610的设备栈
18、!drvobj disk 2  查看disk的驱动的基本信息，以及IRP派发函数
19、bu CLASSPNP!ClassGlobalDispatch     针对某个IRP派发函数，断点调试它的行为，或者查看它的调用栈
20、bl
21、k
22、qd
```

# Debugging Techniques

通用调试技术和特殊调试技术

## Standard Debugging Techniques

### Using Breakpoints

命令：

```txt
bl（Breakpoint list）
.bpcmds（Display Breakpoint Commands）
bp（Set Breakpoint）：下即时断点
bu（Set Unresolved Breakpoint）：模块符号还未加载前，设置这个断点
bm（Set Symbol Breakpoint）：类似bu，如果加了/d，类似bp
ba（Break on Access）：数据断点，某个位置的发生读、写、执行、IO时，会触发断点
bc（Breakpoint Clear）：清除一个或多个断点
bd（Breakpoint Disable）：临时禁用断点
be（Breakpoint Enable）
br（Breakpoint Renumber）：？
bs（Update Breakpoint Command）：改变一个与断点关联的命令
bsc（Update Conditional Breakpoint）：更新条件断点的触发条件
```

在某处中断，然后写dump，然后继续执行

```txt
bu MyFunction+0x47 ".dump c:\mydump.dmp; g"
```

数据断点：

```txt
ba r4 MyValue       这是在MyValue符号开始后的4字节，读的时候，触发断点

```

条件断点：

```txt
格式：
0:000> bp Address "j (Condition) 'OptionalCommands'; 'gc' "
0:000> bp Address ".if (Condition) {OptionalCommands} .else {gc}"

例子：
0:000> bp `mysource.cpp:143` "j (poi(MyVar)>0n20) ''; 'gc' " 
0:000> bp `mysource.cpp:143` ".if (poi(MyVar)>0n20) {} .else {gc}"

其中，poi表示解引用，针对某个变量MyVar，使用一个poi表示它的地址；如果是一个指针MyPoint，需要两个poi(poi(MyPoint))表示它的值

使用命令
0:000> bp `:143` "j (poi(MyVar)>5) '.echo MyVar Too Big'; '.echo MyVar Acceptable; gc' " 
0:000> bp `:143` ".if (poi(MyVar)>5) {.echo MyVar Too Big} .else {.echo MyVar Acceptable; gc} "
```

条件基于字符串的匹配的条件断点的使用：

```txt
首先下一个断点，并制定一个脚本文件的命令集：bp kernel32!CreateEventW "$$<c:\\commands.txt"
然后，commands.txt中的内容如下：
.if (@r9 != 0) { as /mu ${/v:EventName} @r9 } .else { ad /q ${/v:EventName} }
.if ($spat(@"${EventName}", "Global*") == 0)  { gc } .else { .echo EventName }

这里要注意：
（1）x64处理器下，release版本的程序，函数的前4个整型或指针参数分别放在了寄存器rcx, rdx, r8, r9；浮点参数存储在xmm0-xmm3寄存器；x86还是放在栈里，需要使用栈偏移
（2）CreateEvent的原型为：HANDLE CreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPTSTR lpName);第四个参数就是name，所以是@r9
（3）as /mu ${/v:EventName} @r9，表达的意思是：给寄存器r9所在地址，取一个别名（as），是一个unicode字符串（/mu），名为EventName（${EventName}），且无论是否有该表达式的关键字在（${/v:}），都这么命名。
（4）ad /q ${/v:EventName}，表达的意思是：从别名列表里面，删除别名为{/v:EventName}的别名，使用安静模式（/q）
（5）$spat(@"${EventName}", "Global*")，表达的意思是：比较两个字符串（$spat("string","pattern")），第一个字符串是"${EventName}"所在地址（@"${EventName}"），第二个字符串可以是一个模糊匹配（Global*）
（6）.echo EventName，表达的意思是：在界面上输出EventName的字符串，至于为啥不使用寄存器，不晓得

参考链接：
https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture
https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-------alias-interpreter-
https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/as--as--set-alias-
https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/ad--delete-alias-
https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/masm-numbers-and-operators
```

条件基于简单的寄存器值的条件断点的使用：

```txt
如果寄存器eax中的值等于0xa3，就会断下来，否则继续执行
0:000> bp mydriver!myFunction "j @eax = 0xa3  '';'gc'" 
0:000> bp mydriver!myFunction ".if @eax = 0xa3  {} .else {gc}"

以下无论如何都不会断下来。原因是：如果在内核模式下，对于超过8位的情况，地址前默认都会加上0xffffffff，也就变成了0xffffffffc0004321
0:000> bp mydriver!myFunction "j @eax = 0xc0004321  '';'gc'" 
0:000> bp mydriver!myFunction ".if @eax = 0xc0004321  {} .else {gc}"
正确用法如下：强制指定了高位为0（0x0`c0004321）
0:000> bp mydriver!myFunction "j (@eax & 0x0`ffffffff) = 0x0`c0004321  '';'gc'" 
0:000> bp mydriver!myFunction ".if (@eax & 0x0`ffffffff) = 0x0`c0004321  {} .else {gc}"

常用条件断点使用范例：
0:000> bu mymod!myFunc+0x3A "j(myVar<7) '.echo "Breakpoint hit, condition myVar<7"'; 'gc'" 
0:000> bu mymod!myFunc+0x3A ".if(myVar<7) {.echo "Breakpoint hit, condition myVar<7"} .else {gc}"
```

只给当前线程下断点：

```txt
只在当前下断点的线程执行nt!ntopenfile的时候，才会中断
kd> bp /t @$thread nt!ntopenfile
```

指定脚本执行：

```txt
.if (@eax == 1234) { .echo 1234 } .else { t "$<eaxstep" }

其中，t "string"，表示trace（单步）执行一个命令
$<表示运行一个脚本文件，脚本文件为eaxstep
```

其他一些说明：

```txt
内核模式下，最多使用32个断点；用户模式，无限个

软件断点：bp、bu、bm
处理器断点：ba

main入口函数不能设置处理器断点

当使用一个调试器启动一个目标程序时，等所有的dll、exe都加载完，还未执行dll的初始化之前，调试器会创建一个初始断点
当调试器是attach上去，会立刻触发初始断点

用户模式使用断点，是设置在用户空间
内核模式使用断点，需要针对某个进程，首先!process 0 0，然后找到对应进程，.process /i xxxxx(这个是进程的地址EPROCESS)，切换后，再下断点
```

查看用户模式地址空间范围和内核模式地址空间范围

```txt
0: kd> dp nt!mmhighestuseraddress L1 
```

### Reading and Writing Memory 

通过虚拟地址访问内存

```txt
可以读写任意格式的内存，包括十六进制、单字、双字、四字、整型（长、短、无符号、8字节）、浮点数、字符串
d*（Display Memory）：展示指定内存或内存范围的内容
e*（Enter Values）：往一个内存地址写值

可以操作特殊数据结构
dt（Display Type）：显示各种数据结构
ds，dS（Display String）：显示STRING，ANSI_STRING，UNICODE_STRING数据结构
d*s（Display Words and Symbols）：显示双字或四字的符号信息
!address：显示特殊地址的内存属性

操作内存范围：
m（Move Memory）：移动一段内存到另一段
f（Fill Memory）：写一个pattern到一个内存范围，重复直到范围写满
c（Compare Memory）：比较两个内存范围
s（Search Memory）：搜索一个特殊的pattern内存，或者搜索任意ASCII或UNICODE字符
.holdmem（Hold and Compare Memory）：比较内存范围

其他：
n（Set Number Base）：切换数值进制
?（Evaluate Expression）：数值格式转换
.formats（Show Number Formats）：数值格式转换显示
```

通过物理地址访问内存

```txt
读物理内存地址：!db, !dc, !dd, !dp, !du, !dw
写物理内存地址：!eb, !ed
填充物理内存：fp
搜索物理内存数据片：!search
可视化：Memory Window，只能在内核调试中使用，不能用于用户模式调试
```

访问全局变量

```txt
直接使用全局变量的符号名，以上所有内存操作的命令，皆可以使用符号名，调试器内部会转换成地址来操作
使用?可以展示任何符号的虚拟内存地址
0:000> ? MyCounter 
Evaluate expression: 1244892 = 0012fedc
0:000> dd 0x0012fedc L1 
0012fedc  00000052

改变符号内容
0:000> ed MyCounter 83 
```

访问局部变量

```txt
所有全局变量的使用方法，均可以用于局部变量。为了告知编译器某个符号是局部变量，在前面加上$!，例如$!local_Var
dv（Display Local Variables）：显示所有的局部变量的符号和名字

!for_each_local ["CommandString"]：针对当前栈帧的每一个局部变量执行某个操作
!for_each_frame：针对所有栈帧执行操作
打印每个栈帧的每个局部变量：
!for_each_frame !for_each_local dt @#Local
```

虚拟内存地址和物理内存地址互转

```txt
虚拟地址到物理地址的转换 —— 使用!vtop
（1）确保使用十六进制工作，如果不是，使用N 16切换一下
（2）确定一个地址的字节索引，例如地址0x0012F980，它的字节索引是0x980（低12位）
（3）确定进程基地址，使用!process 0 0，例如获取到的DirBase为0x098fd000
（4）确定进程基地址的分页编号（page frame number），这个是0x098fd（去掉低12位）
（5）使用!vtop 分页编号 虚拟地址
kd> !vtop 98fd 12f980
Pdi 0 Pti 12f
0012f980 09de9000 pfn(09de9)
这里，第二个数09de9000就是物理地址页的开始地址
（6）字节索引+物理地址开始页地址，就是最终的物理地址
0x09DE9000 + 0x980 = 0x09DE9980
（7）鉴定是否正确
kd> !dc 9de9980
# 9de9980 6d206e49 726f6d65 00120079 0012f9f4 In memory.......
# 9de9990 0012f9f8 77e57119 77e8e618 ffffffff .....q.w...w....
# 9de99a0 77e727e0 77f6f13e 77f747e0 ffffffff .'.w>..w.G.w....
# 9de99b0 .....
kd> dc 12f980
0012f980  6d206e49 726f6d65 00120079 0012f9f4  In memory.......
0012f990  0012f9f8 77e57119 77e8e618 ffffffff  .....q.w...w....
0012f9a0  77e727e0 77f6f13e 77f747e0 ffffffff  .'.w>..w.G.w....
0012f9b0  .....

-----------------------------------------------------------------

虚拟地址到物理地址的转换 —— 使用!pte
（1）确保使用十六进制工作，如果不是，使用N 16切换一下
（2）确定一个地址的字节索引，例如地址0x0012F980，它的字节索引是0x980（低12位）
（3）设置进程上下文为指定的进程
kd> !process 0 0
**** NT ACTIVE PROCESS DUMP ****
....
PROCESS ff779190  SessionId: 0  Cid: 04fc    Peb: 7ffdf000  ParentCid: 0394
    DirBase: 098fd000  ObjectTable: e1646b30  TableSize:   8.
    Image: MyApp.exe
kd> .process /p ff779190
Implicit process is now ff779190
.cache forcedecodeuser done
（4）使用!pte 虚拟地址
kd> !pte 12f980
               VA 0012f980
PDE at   C0300000        PTE at C00004BC
contains 0BA58067      contains 09DE9067
pfn ba58 ---DA--UWV    pfn 9de9 ---DA--UWV
（5）pfn 9de9，表示的是PTE表的页编号索引，左移动12位，即是分页的物理地址头0x09de9000
（6）字节索引+物理地址开始页地址，就是最终的物理地址
0x09DE9000 + 0x980 = 0x09DE9980
```

### Using the !analyze Extension

```txt
使用!analyze -v，分析一般的crash
使用!analyze -hang，分析线程挂起引起的死锁阻塞问题
内核调试下，使用!deadlock，分析内核资源死锁问题
使用!analyze -f，强制使用!analyze -v，及时没有crash发生
```

### Noninvasive Debugging (User Mode)

非侵入式调试，特别适用于在目标程序已经无响应的情况  

![png](/images/post/windbg/1.png)

### Debugging in Assembly Mode

```txt
反汇编指令：
u（Unassemble）：反汇编显示一部分汇编代码
uf（Unassemble Function）：反汇编显示一个函数的汇编代码
up（Unassemble from Physical Memory）：反汇编显示存储在物理内存中的汇编代码
ur（Unassemble Real Mode BIOS）：反汇编显示16位实模式汇编代码
ux（Unassemble x86 BIOS）：反汇编基于X86指令集的汇编代码
```

### Changing Contexts

有5种上下文概念

```txt
session context：多用户登录时，默认是当前登录用户。使用命令!session
process context：内核调试时，虚拟地址如何翻译问题。使用命令.process
user-mode address context：从来不会直接设置，切换进程上下文自动会切换该上下文
register context：也称为thread context，控制栈回溯。
        用户模式下使用如下命令切换线程上下文：
        .cxr（Display Context Record）
        .ecxr（Display Exception Context Record）
        内核模式下使用如下命令切换线程上下文：
        .thread（Set Register Context）
        .cxr（Display Context Record）
        .trap（Display Trap Frame）
local context：翻译局部变量的时候用，区间内的。
        使用命令：.frame（Set Local Context）切换栈帧，可以针对不同栈帧使用dv -v导出局部变量
```

### Controlling Processes and Threads

调试器可以切换进程或线程，也可以控制线程freeze或unfreeze

```txt
显示进程和线程
|（Process Status）
~（Thread Status）

设置当前进程和线程
|s（Set Current Process）
~s（Set Current Process）

冻结和挂起线程
~n（Suspend Thread）
~m（Resume Thread）
~f（Freeze Thread）
~u（Unfreeze Thread）
```

### Controlling Exceptions and Events

首先，异常是有一个链表结构，链表的尾部是调试器，链表的前面如果有任意一个服务已经处理了异常，就轮不到调试器了。只有未处理异常，才会中断到调试器中。  
调试器可以恢复继续执行，使用命令：gh（Go with Exception Handled）或者gn（Go with Exception Not Handled）。  

内核未处理异常，会直接引发bug check蓝屏

### Debugging a Stack Overflow



## Specialized Debugging Techniques