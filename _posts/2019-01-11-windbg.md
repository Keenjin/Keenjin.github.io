---
layout: post
title: windbg帮助文档
date: 2019-01-11
tags: 调试  
---

# Debugging Tools for Windows (WinDbg, KD, CDB, NTSD)

```txt
1、3种方式获取调试工具：WDK、SDK、standalone tool set
```

## Getting Started with Windows Debugging

```txt
调试基本流程：
1、确定主机和目标机
2、确定调试内核还是应用层
3、按需选择调试工具
4、选择主机和目标机连接方式：网络、串口、USB、虚拟机
5、选择32位还是64位调试工具
6、配置符号
7、配置源码
8、熟悉调试工具操作方法
9、熟悉调试技术
10、使用调试指令
11、使用调试扩展
```

### Getting Started with WinDbg (User-Mode)

```txt
为什么不注入到目标进程，都可以进行调试？

答：因为操作系统内核体系支持，只要应用层调用DebugActiveProcess启动调试，操作系统会触发int 3中断（从调用栈里看是这玩意儿：ntdll!DbgUiRemoteBreakin、ntdll!DbgBreakPoint），这个中断向量表里填充的响应函数是kiTrap，这个东西首先分发给调试系统，然后才会分发给中断异常系统。所以本质是利用中断和系统本身的内核级调试支持。剩下的，就是各种调试事件的使用。
```

```txt
如何调试一个应用层程序？步骤如下：
1、.sympath srv*xxxx        xxxx表示符号路径，可以是网络路径，微软的符号服务器路径：http://msdl.microsoft.com/download/symbols，当然，这里可以直接使用界面设置
2、.reload      加载模块pdb，将从刚设置的位置搜索
3、x notepad!*  检查符号加载
4、g
5、菜单Break——>Debug
6、lm
7、k
8、bu notepad!WinMain
9、bl       设置完断点，列一下确认下
10、~       罗列所有的线程id
11、~3s     切换到线程id为3的线程栈，然后k
12、!analyze -v     中断后，可以使用命令分析，得出基本结论和中断位置
13、qd      Quit and Detach
```

### Getting Started with WinDbg (Kernel-Mode)

```txt
调试驱动准备环境：
1、双机调试
2、双机连接方式：
（1）Win8及以上，可以使用网络连接
（2）Win8以下只能用usb、serial、1394
3、启动连接会话
（1）手动方法：https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-kernel-mode-debugging-in-windbg--cdb--or-ntsd
（2）自动方法：使用Virtual-KD工具，将目录里面的target拷贝到目标机器，执行vminstall.exe；然后主机运行vmmon.exe，启动windbg即可

```

```txt
如何调试一个驱动？步骤如下：
1、建立双机连接
2、设置符号表
3、lm
4、x nt!*CreateProcess*     检查符号表
5、dt nt!_FILE_OBJECT       常用结构查看
6、bu nt!MmCreateProcessAddressSpace    设置断点
7、bl
8、g
9、k
10、bc *            清除所有断点
11、!process 0 0    输出所有当前进程的基本信息
12、!process ffffe00000d5290 2      输出某个进程的线程信息（ffffe00000d5290是进程句柄，标志进程地址）
13、!thread ffffe00000e6d080        某个线程的相关信息，特别是包括堆栈详细信息
14、!devnode 0 1    查看所有即插即用设备树信息
15、!devnode 0 9    查看设备信息及硬件资源
16、!devnode 0 1 disk       查看服务名为disk的设备信息
17、!devstack 0xffffe00001159610    查看pdo为0xffffe00001159610的设备栈
18、!drvobj disk 2  查看disk的驱动的基本信息，以及IRP派发函数
19、bu CLASSPNP!ClassGlobalDispatch     针对某个IRP派发函数，断点调试它的行为，或者查看它的调用栈
20、bl
21、k
22、qd
```

# Debugging Techniques

通用调试技术和特殊调试技术

## Standard Debugging Techniques

### Using Breakpoints

命令：

```txt
bl（Breakpoint list）
.bpcmds（Display Breakpoint Commands）
bp（Set Breakpoint）：下即时断点
bu（Set Unresolved Breakpoint）：模块符号还未加载前，设置这个断点
bm（Set Symbol Breakpoint）：类似bu，如果加了/d，类似bp
ba（Break on Access）：数据断点，某个位置的发生读、写、执行、IO时，会触发断点
bc（Breakpoint Clear）：清除一个或多个断点
bd（Breakpoint Disable）：临时禁用断点
be（Breakpoint Enable）
br（Breakpoint Renumber）：？
bs（Update Breakpoint Command）：改变一个与断点关联的命令
bsc（Update Conditional Breakpoint）：更新条件断点的触发条件
```

在某处中断，然后写dump，然后继续执行

```txt
bu MyFunction+0x47 ".dump c:\mydump.dmp; g"
```

数据断点：

```txt
ba r4 MyValue       这是在MyValue符号开始后的4字节，读的时候，触发断点

```

条件断点：

```txt
格式：
0:000> bp Address "j (Condition) 'OptionalCommands'; 'gc' "
0:000> bp Address ".if (Condition) {OptionalCommands} .else {gc}"

例子：
0:000> bp `mysource.cpp:143` "j (poi(MyVar)>0n20) ''; 'gc' " 
0:000> bp `mysource.cpp:143` ".if (poi(MyVar)>0n20) {} .else {gc}"

其中，poi表示解引用，针对某个变量MyVar，使用一个poi表示它的地址；如果是一个指针MyPoint，需要两个poi(poi(MyPoint))表示它的值

使用命令
0:000> bp `:143` "j (poi(MyVar)>5) '.echo MyVar Too Big'; '.echo MyVar Acceptable; gc' " 
0:000> bp `:143` ".if (poi(MyVar)>5) {.echo MyVar Too Big} .else {.echo MyVar Acceptable; gc} "
```

条件基于字符串的匹配的条件断点的使用：

```txt
首先下一个断点，并制定一个脚本文件的命令集：bp kernel32!CreateEventW "$$<c:\\commands.txt"
然后，commands.txt中的内容如下：
.if (@r9 != 0) { as /mu ${/v:EventName} @r9 } .else { ad /q ${/v:EventName} }
.if ($spat(@"${EventName}", "Global*") == 0)  { gc } .else { .echo EventName }

这里要注意：
（1）x64处理器下，release版本的程序，函数的前4个整型或指针参数分别放在了寄存器rcx, rdx, r8, r9；浮点参数存储在xmm0-xmm3寄存器；x86还是放在栈里，需要使用栈偏移
（2）CreateEvent的原型为：HANDLE CreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPTSTR lpName);第四个参数就是name，所以是@r9
（3）as /mu ${/v:EventName} @r9，表达的意思是：给寄存器r9所在地址，取一个别名（as），是一个unicode字符串（/mu），名为EventName（${EventName}），且无论是否有该表达式的关键字在（${/v:}），都这么命名。
（4）ad /q ${/v:EventName}，表达的意思是：从别名列表里面，删除别名为{/v:EventName}的别名，使用安静模式（/q）
（5）$spat(@"${EventName}", "Global*")，表达的意思是：比较两个字符串（$spat("string","pattern")），第一个字符串是"${EventName}"所在地址（@"${EventName}"），第二个字符串可以是一个模糊匹配（Global*）
（6）.echo EventName，表达的意思是：在界面上输出EventName的字符串，至于为啥不使用寄存器，不晓得
```

条件基于简单的寄存器值的条件断点的使用：

```txt
如果寄存器eax中的值等于0xa3，就会断下来，否则继续执行
0:000> bp mydriver!myFunction "j @eax = 0xa3  '';'gc'" 
0:000> bp mydriver!myFunction ".if @eax = 0xa3  {} .else {gc}"

以下无论如何都不会断下来。原因是：如果在内核模式下，对于超过8位的情况，地址前默认都会加上0xffffffff，也就变成了0xffffffffc0004321
0:000> bp mydriver!myFunction "j @eax = 0xc0004321  '';'gc'" 
0:000> bp mydriver!myFunction ".if @eax = 0xc0004321  {} .else {gc}"
正确用法如下：强制指定了高位为0（0x0`c0004321）
0:000> bp mydriver!myFunction "j (@eax & 0x0`ffffffff) = 0x0`c0004321  '';'gc'" 
0:000> bp mydriver!myFunction ".if (@eax & 0x0`ffffffff) = 0x0`c0004321  {} .else {gc}"

常用条件断点使用范例：
0:000> bu mymod!myFunc+0x3A "j(myVar<7) '.echo "Breakpoint hit, condition myVar<7"'; 'gc'" 
0:000> bu mymod!myFunc+0x3A ".if(myVar<7) {.echo "Breakpoint hit, condition myVar<7"} .else {gc}"
```

其他一些说明：

```txt
内核模式下，最多使用32个断点；用户模式，无限个

软件断点：bp、bu、bm
处理器断点：ba

main入口函数不能设置处理器断点

当使用一个调试器启动一个目标程序时，等所有的dll、exe都加载完，还未执行dll的初始化之前，调试器会创建一个初始断点
当调试器是attach上去，会立刻触发初始断点

用户模式使用断点，是设置在用户空间
内核模式使用断点，需要针对某个进程，首先!process 0 0，然后找到对应进程，.process /i xxxxx(这个是进程的地址EPROCESS)，切换后，再下断点
```

查看用户模式地址空间范围和内核模式地址空间范围

```txt
0: kd> dp nt!mmhighestuseraddress L1 
```


## Specialized Debugging Techniques